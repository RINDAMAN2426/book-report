# Chapter 1. 컴퓨터 내부의 언어체계

## 언어란

모든 언어의 뜻은 기호의 집합으로 `encoding`

의사소통을 위해선 당사자들간의 `context` 공유가 필요

## 문자 언어

문자의 구성요소는 `기호가 들어갈 상자`, `상자에 들어갈 기호`, `상자의 순서`

## 비트

`기호가 들어갈 상자`는 자연어에서는 `character`, 컴퓨터에서는 `bit`

비트는 2진법을 사용

## 논리 연산

자연어에서 `예/아니요` 구절을 엮어서 한 문장으로 만드는 경우와 같이, 다른 비트들이 나타내는 내용으로 부터 새로운 비트를 만들어 내는 것이 `논리 연산(logic operation)`

### 불리언 대수

영국 수학자 George Boole이 만들어낸 `불리언 대수(Boolean algebra)`는 비트에 대해 사용할 수 있는 연산 규칙의 집합

연산자는 `NOT`, `AND`, `OR`, `XOR`

### 드모르간의 법칙

영국 수학자 Augustus De Morgan이 발견한 법칙

`a AND b = NOT(NOT a OR NOT b)`

연산의 연쇄 사용과 NOT 연산은 비용이 많이 들기도 하기 때문에 이를 이용하여 연산의 수를 줄여서 효율성을 높일 수 있음

## 비트를 이용한 정수

### 양의 정수

사람은 손가락도 10개, 발가락도 10개이기 때문에 10진수를 사용함

10진수는 오른쪽부터 왼쪽으로 상자가 지수, 밑은 10을 이용한 표기법

비트는 밑을 2를 사용한 표기법

가장 오른쪽 비트를 `가장 작은 유효 비트(least significant bit)`, 가장 왼쪽 비트를 `가장 큰 유효 비트(most significant bit)`라고 하며, 줄여서 `LSB`, `MSB`라고도 함

비트 덧셈은 논리연산으로도 표현이 가능함
- A=0, B=0 -\> A AND B = 0, A XOR B = 0 따라서 00
- A=0, B=1 -\> A AND B = 0, A XOR B = 1 따라서 01
- A=1, B=0 -\> A AND B = 0, A XOR B = 1 따라서 01
- A=1, B=1 -\> A AND B = 1, A XOR B = 0 따라서 10

위 예시를 통해 알 수 있는 것은 두 비트를 더한 상자값은 XOR 값과 같고, 올림 상자 값은 AND 연산 값과 같다

실제로는 올림 값을 고려한 3비트 덧셈을 수행하는 경우가 대다수이지만 이는 결국 덧셈 결합 법칙에 의해 2비트 연산을 두번 하면 된다. 예) 001 + 101

위의 덧셈 결과가 표현 가능한 비트 개수를 초과하게 되는 경우 `오버 플로(overflow)` 발생. 즉 `MSB`에서 올림이 발생했다는 뜻

컴퓨터에는 `조건 코드(상태 코드) 레지스터 (condition code register)`라는 것이 있어 몇 가지 이상한 정보를 저장함. 이 정보에는 `overflow bit`가 있고 이 비트에는 `MSB`에서 발생한 올림값이 들어감. 이 비트 값을 통하여 `overflow`가 발생했는지를 알 수 있음

반대로 `MSB`에서 1을 빌려오는 경우는 `underflow`라고 표현함

### 음수 표현

비트 표현은 결국 컴퓨터 언어 표현이기 때문에 새로운 문맥의 형성도 가능함

음수, 양수 구별을 위한 `부호(sign)`을 사용하며 두 가지 표현이 필요하기 때문에 이 또한 비트 하나를 통하여 표현이 가능함

`MSB`에 부호를 사용하여 이를 표현하고 있음. 단 0의 경우는 동일하기 때문에 표현 개수는 부호 표현을 하지 않을 때보다 1개 부족함

`부호와 크기(sign and magnitude) 표현법`은 아래 두가지 이유로 인해 널리 쓰이지 못함 (크기 표현법이란 0으로 부터의 거리 즉 절대값 표현)
- 비트 구성을 위해선 비용이 발생하는데 0을 표현하는 방법이 두 가지가 되기 때문에 비용의 낭비
- XOR과 AND를 이용한 덧셈 계산을 사용할 수 없음

예시로 -1과 1의 연산이 있음
- -1(1001) + 1(0001)의 XOR,AND 결과는 -2(1010)가 되서 다른 결과가 발생함

더 복잡한 로직을 이용하여 연산이 제대로 작동하게 할 수 있지만 항상 가능한 간단하게 유지하는 것이 더 가치가 있음. 이를 위한 다른 표현 방법들이 존재함

### 1의 보수

`1의 보수(one's complement)`는 음수 표현의 또 다른 방법이며 모든 양수 비트를 뒤집는 방법

부호와 크기 표현법과 비슷하게 부호 비트와 나머지로 나누게 됨
- 0(0000)의 보수는 0(1111)
- 1(0001)의 보수는 -1(1110)
- 7(0111)의 보수는 -7(1000)

이 표현법에서도 0의 표현법이 여전히 두개 존재한다는 문제점이 존재

또한 여기서도 덧셈을 쉽게 할 수는 없음. 덧셈을 위해선 `MSB`에서 발생한 올림 값을 `LSB`로 전달이 필요`(순환올림, end-around carry)`. 작동은 잘 하겠지만 결국 순환올림 처리를 위한 하드웨어 추가가 필요해짐

따라서 부호와 크기 표현법, 1의 보수 표현법은 현대 컴퓨터에서는 사용하지 않음. 앞서 말했듯이 추가 하드웨어가 필요하고 그 말은 즉 비용이 더 든다는 이야기

